{"version":3,"file":"serialize.js","sources":["../src/serialize.js"],"sourcesContent":["import reduce from 'lodash.reduce';\nimport isObject from 'lodash.isobject';\nimport flow from 'lodash.flow';\nimport isNaN from 'lodash.isnan';\nimport isError from 'lodash.iserror';\nimport isArguments from 'lodash.isarguments';\nimport isRegExp from 'lodash.isregexp';\nimport toArray from 'lodash.toarray';\n\nimport jsonSS from 'json-stringify-safe';\n\n// patterns\nconst stackDelim = /\\n\\s*/g;\n\n// util\nconst pass = (key, val) => val;\n\nconst isNewIterable = val => {\n  const isMap = (Map && val instanceof Map);\n  const isSet = (Set && val instanceof Set);\n  const isWeakMap = (WeakMap && val instanceof WeakMap);\n  const isWeakSet = (WeakSet && val instanceof WeakSet);\n\n  return isMap || isSet || isWeakMap || isWeakSet;\n};\n\n// Though it might be a nice touch to spread generators too, it’d be way too\n// presumptuous (could have side effects, could be infinite). As it is,\n// functions and generators both just disappear into the night, though the\n// user can change this with a custom replacer.\nconst errReplacer = (val, withStack) => {\n  // Errors do not serialize nicely with JSON.stringify because none of the\n  // properties of interest are ‘own’ properties.\n\n  const err = { name: val.name || 'Error', message: val.message };\n\n  // Though custom errors could have some own properties:\n  Object.assign(err, val);\n\n  // For the stack, we convert to an array for the sake of readability.\n\n  if (withStack) err.stack = val.stack && val.stack.split(stackDelim);\n\n  return err;\n};\n\nconst flat = (serialize, arraysToo) =>\n    (obj) => {\n      const serializedObj = JSON.parse(serialize(obj));\n      if (!isObject(serializedObj)) return serializedObj;\n\n      const flatObj = reduce(serializedObj, function _flat(target, val, key) {\n        const keyContext = this.slice();\n        keyContext.push(key);\n\n        const joinedKey = keyContext.join('.');\n        const newTarget = target;\n        if (!isObject(val)) {\n          newTarget[joinedKey] = val;\n        } else if (!arraysToo && Array.isArray(val)) {\n          newTarget[joinedKey] = val.map(newVal => {\n            if (!isObject(newVal)) return newVal;\n\n            return reduce(newVal, _flat, {}, []);\n          });\n        } else {\n          reduce(val, _flat, newTarget, keyContext);\n        }\n\n        return newTarget;\n      }, {}, []);\n\n      return jsonSS(flatObj);\n    };\n\n// build serializer\nconst build = ({\n    flatten, flattenArrays, replacer = pass,\n    withStack\n}) => {\n  // We augment the default JSON.stringify serialization behavior with\n  // handling for a number of values that otherwise return nonsense values or\n  // nothing at all. In addition to numeric outliers, a number of other basic\n  // JS objects (post-ES6 especially) aren’t in the JSON spec, presumably\n  // because it would have been too obvious that we were tricking everyone\n  // else into making our lives easier. This augmented behavior is useful in a\n  // JS environment since we’re not apt to think ‘I am going to log JSON!’; we\n  // just want to dump objects in the log hole.\n\n  // If the user supplied a custom replacer, it is applied first.\n  const replace = flow(replacer, val => {\n    // Prototypeless object\n    if (isObject(val) && !Object.getPrototypeOf(val)) {\n      return val;\n    }\n\n    if (isObject(val) && !(val instanceof Object)) {\n      return val;\n    }\n\n    // Trouble primitives\n    if (isNaN(val)) return 'NaN';\n    if (val === Infinity) return 'Infinity';\n    if (val === -Infinity) return '-Infinity';\n    if (1 / val === -Infinity) return '-0';\n    if (typeof val === 'symbol') return val.toString();\n\n    // Trouble objects\n    if (isError(val)) return errReplacer(val, withStack);\n    if (isArguments(val)) return toArray(val);\n    if (isRegExp(val)) return val.toString();\n    if (isNewIterable(val)) return [...val];\n\n    // - Error, regexp, maps and sets would have been `{}`\n    // - Arguments would have been `{\"0\": \"arg1\", \"1\": \"arg2\" }`\n    // - NaN and +/-Infinity would have been `null` (wtf?)\n    // - -0 would have been 0 (yes I’m being overly thorough)\n    // - Symbols would have been undefined\n\n    // Note: numeric literals in base-whatever are just standard decimal\n    // integers internally, so 0b1 will be \"1\" -- the original notation\n    // can’t be preserved. JSON does preserve exponent suffixes though.\n    return val;\n  });\n\n  // json-stringify-safe is a JSON.stringify wrapper that takes care of\n  // circular references.\n\n  const serialize = (...args) => jsonSS(...args, replace);\n\n  return flatten ? flat(serialize, flattenArrays) : serialize;\n};\n\nexport { build as default };\n"],"names":["default","flatten","flat","serialize","flattenArrays","jsonSS","args","replace","val","isNewIterable","toString","errReplacer","withStack","Infinity","Object","replacer","pass","build","flatObj","newTarget","_flat","keyContext","newVal","joinedKey","map","arraysToo","Array","isArray","target","join","push","key","slice","serializedObj","JSON","parse","obj","err","stack","split","stackDelim","name","message","isMap","isSet","isWeakMap","isWeakSet"],"mappings":"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"}